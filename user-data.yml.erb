#cloud-config

coreos:
  update:
    group: stable
  etcd:
    # generate a new token for each unique cluster from https://discovery.etcd.io/new
    # WARNING: replace each time you 'vagrant destroy'
    discovery: <%= ENV["ETCD_DISCOVERY"] %>
    addr: $public_ipv4:4001
    peer-addr: $public_ipv4:7001
  fleet:
    public-ip: $public_ipv4
  units:
    - name: journal-router-short.service
      command: start
      content: |
        [Unit]
        Description=Journal Router (short)

        [Service]
        TimeoutStartSec=0
        ExecStart=/bin/sh -c '/usr/bin/journalctl -o short -f | sed \"s/^/<%= ENV["LOGENTRIES_TOKEN_JOURNAL_SHORT"] %> \\0/g\" | ncat data.logentries.com 10000'

        [Install]
        WantedBy=multi-user.target
    - name: journal-router-json.service
      command: start
      content: |
        [Unit]
        Description=Journal Router (json)

        [Service]
        TimeoutStartSec=0
        ExecStart=/bin/sh -c '/usr/bin/journalctl -o json -f | sed \"s/^/<%= ENV["LOGENTRIES_TOKEN_JOURNAL_JSON"] %> \\0/g\" | ncat data.logentries.com 10000'

        [Install]
        WantedBy=multi-user.target
    - name: settimezone.service
      command: start
      content: |
        [Unit]
        Description=Set the timezone

        [Service]
        ExecStart=/usr/bin/timedatectl set-timezone Asia/Tokyo
        RemainAfterExit=yes
        Type=oneshot
    - name: etcd.service
      command: start
    - name: fleet.service
      command: start
    - name: docker-tcp.socket
      command: start
      enable: true
      content: |
        [Unit]
        Description=Docker Socket for the API

        [Socket]
        ListenStream=2375
        Service=docker.service
        BindIPv6Only=both

        [Install]
        WantedBy=sockets.target
    - name: registry.service
      command: start
      enable: true
      content: |
        [Unit]
        Description=Private Docker Registry
        After=docker.service
        Requires=docker.service

        [Service]
        TimeoutStartSec=0
        ExecStartPre=-/usr/bin/docker kill registry
        ExecStartPre=-/usr/bin/docker rm registry
        ExecStartPre=/usr/bin/docker pull registry:0.7.3
        ExecStart=/usr/bin/docker run --name registry -h %H -e SETTINGS_FLAVOR=prod -e AWS_KEY=<%= ENV["REGISTRY_AWS_KEY"] %> -e AWS_SECRET=<%= ENV["REGISTRY_AWS_SECRET"] %> -e AWS_BUCKET=<%= ENV["REGISTRY_AWS_BUCKET"] %> -e AWS_SECURE=true -e DOCKER_REGISTRY_CONFIG=/docker-registry/config/config_sample.yml -e STORAGE_PATH=/ -e SEARCH_BACKEND=sqlalchemy -e GUNICORN_WORKERS=3 -e LOGLEVEL=info -p 5000:5000 registry:0.7.3 docker-registry
        ExecStop=/usr/bin/docker stop registry

        [Install]
        WantedBy=multi-user.target
    - name: dd-agent.service
      command: start
      enable: true
      content: |
        [Unit]
        Description=Datadog Agent
        After=docker.service
        Requires=docker.service

        [Service]
        TimeoutStartSec=0
        ExecStartPre=-/usr/bin/docker kill dd-agent
        ExecStartPre=-/usr/bin/docker rm dd-agent
        ExecStartPre=/usr/bin/docker pull datadog/docker-dd-agent:latest
        ExecStart=/usr/bin/docker run --privileged --name dd-agent -h %H -v /var/run/docker.sock:/var/run/docker.sock -v /proc/mounts:/host/proc/mounts:ro -v /sys/fs/cgroup/:/host/sys/fs/cgroup:ro -e API_KEY=<%= ENV["DATADOG_API_KEY"] %> datadog/docker-dd-agent:latest
        ExecStop=/usr/bin/docker stop dd-agent

        [Install]
        WantedBy=multi-user.target
    - name: registrator.service
      command: start
      enable: true
      content: |
        [Unit]
        Description=Registrator
        After=docker.service
        Requires=docker.service

        [Service]
        TimeoutStartSec=0
        ExecStartPre=-/usr/bin/docker kill registrator
        ExecStartPre=-/usr/bin/docker rm registrator
        ExecStartPre=/usr/bin/docker pull progrium/registrator:latest
        ExecStart=/usr/bin/docker run --name registrator -h %H -v /var/run/docker.sock:/tmp/docker.sock progrium/registrator:latest -ip=$private_ipv4 etcd://$private_ipv4:4001/services
        ExecStop=/usr/bin/docker stop registrator

        [Install]
        WantedBy=multi-user.target
    - name: logspout.service
      command: start
      enable: true
      content: |
        [Unit]
        Description=Logspout
        After=docker.service
        Requires=docker.service

        [Service]
        TimeoutStartSec=0
        ExecStartPre=-/usr/bin/docker kill logspout
        ExecStartPre=-/usr/bin/docker rm logspout
        ExecStartPre=/usr/bin/docker pull progrium/logspout:latest
        ExecStart=/usr/bin/docker run --name logspout -h %H -p 8000:8000 -v=/var/run/docker.sock:/tmp/docker.sock progrium/logspout:latest
        ExecStop=/usr/bin/docker stop logspout

        [Install]
        WantedBy=multi-user.target
users:
  - name: spesnova
    coreos-ssh-import-github: spesnova
    groups:
      - sudo
      - docker
  - name: git
    groups:
      - docker
write_files:
  - path: /etc/ssh/sshd_config
    permissions: 0600
    owner: root:root
    content: |
      # Use most defaults for sshd configuration.
      UsePrivilegeSeparation sandbox
      Subsystem sftp internal-sftp

      PermitRootLogin no
      PasswordAuthentication no
      ChallengeResponseAuthentication no
  - path: /etc/ntp.conf
    content: |
      # Common pool
      server 0.pool.ntp.org
      server 1.pool.ntp.org
      server 2.pool.ntp.org
      server 3.pool.ntp.org

      # - Allow only time queries, at a limited rate.
      # - Allow all local queries (IPv4, IPv6)
      restrict default nomodify nopeer noquery limited kod
      restrict 127.0.0.1
      restrict [::1]
  - path: /opt/bin/docker-enter
    permissions: 0755
    owner: root:root
    content: |
      #!/bin/sh
      #
      # Original Source:
      #   https://github.com/jpetazzo/nsenter/blob/master/docker-enter
      #

      if [ -e $(dirname "$0")/nsenter ]; then
          # with boot2docker, nsenter is not in the PATH but it is in the same folder
          NSENTER=$(dirname "$0")/nsenter
      else
          NSENTER=nsenter
      fi

      if [ -z "$1" ]; then
          echo "Usage: docker-enter CONTAINER [COMMAND [ARG]...]"
          echo ""
          echo "Enters the Docker CONTAINER and executes the specified COMMAND."
          echo "If COMMAND is not specified, runs an interactive shell in CONTAINER."
      else
          PID=$(docker inspect --format "{{.State.Pid}}" "$1")
          if [ -z "$PID" ]; then
              exit 1
          fi
          shift

          OPTS="--target $PID --mount --uts --ipc --net --pid --"

          if [ -z "$1" ]; then
              # No command given.
              # Use su to clear all host environment variables except for TERM,
              # initialize the environment variables HOME, SHELL, USER, LOGNAME, PATH,
              # and start a login shell.
              "$NSENTER" $OPTS su - root
          else
              # Use env to clear all host environment variables.
              "$NSENTER" $OPTS env --ignore-environment -- "$@"
          fi
      fi
  - path: /opt/bin/gitreceive
    permissions: 0755
    owner: root:root
    content: |
      #!/bin/bash

      readonly GITUSER="${GITUSER:-git}"
      readonly GITHOME="/home/$GITUSER"

      # Given a relative path, calculate the absolute path
      absolute_path() {
        pushd "$(dirname $1)" > /dev/null
        local abspath="$(pwd -P)"
        popd > /dev/null
        echo "$abspath/$(basename $1)"
      }

      # Create a Git user on the system, with home directory and an `.authorized_keys' file that contains the public keys
      # for all users that are allowed to push their repos here. User defaults to $GITUSER, which defaults to 'git'.
      setup_git_user() {
        declare home_dir="$1" git_user="$2"
        useradd -d "$home_dir" "$git_user" || true
        mkdir -p "$home_dir/.ssh"
        touch "$home_dir/.ssh/authorized_keys"
        chown -R "$git_user" "$home_dir"
      }

      # Creates a sample receiver script. This is the script that is triggered after a successful push.
      setup_receiver_script() {
        declare home_dir="$1" git_user="$2"
        local receiver_path="$home_dir/receiver"
        cat > "$receiver_path" <<EOF
      #!/bin/bash
      #URL=http://requestb.in/rlh4znrl
      #echo "----> Posting to \$URL ..."
      #curl \\
      #  -X 'POST' \\
      #  -F "repository=\$1" \\
      #  -F "revision=\$2" \\
      #  -F "username=\$3" \\
      #  -F "fingerprint=\$4" \\
      #  -F contents=@- \\
      #  --silent \$URL
      EOF
        chmod +x "$receiver_path"
        chown "$git_user" "$receiver_path"
      }

      # Generate a shorter, but still unique, version of the public key associated with the user doing `git push'
      generate_fingerprint() {
        awk '{print $2}' | base64 -d | md5sum | awk '{print $1}' | sed -e 's/../:&/2g'
      }

      # Given a public key, add it to the .authorized_keys file with a 'forced command'. The 'forced command' is a syntax
      # specific to SSH's `.authorized_keys' file that allows you to specify a command that is run as soon as a user logs in.
      # Note that even though `git push' does not explicitly mention SSH, it is nevertheless using the SSH protocol under the
      # hood.
      # See: http://man.finalrewind.org/1/ssh-forcecommand/
      install_authorized_key() {
        declare key="$1" name="$2" home_dir="$3" git_user="$4" self="$5"
        local fingerprint="$(echo "$key" | generate_fingerprint)"
        local forced_command="GITUSER=$git_user $self run $name $fingerprint"
        local key_options="command=\"$forced_command\",no-agent-forwarding,no-pty,no-user-rc,no-X11-forwarding,no-port-forwarding"
        echo "$key_options $key" >> "$home_dir/.ssh/authorized_keys"
      }

      # Remove the slash from the beginning of a path. Eg; '/twbs/bootstrap' becomes 'twbs/bootstrap'
      strip_root_slash() {
        local str="$(cat)"
        if [ "${str:0:1}" == "/" ]; then
          echo "$str" | cut -c 2-
        else
          echo "$str"
        fi
      }

      # Get the repo from the incoming SSH command. This is needed as the original intended response to `git push' is
      # overridden by the use of a 'forced command' (see install_authorized_key()). The forced command needs to know what repo
      # to act on.
      parse_repo_from_ssh_command() {
        #awk '{print $2}' | perl -pe 's/(?<!\\)'\''//g' | sed 's/\\'\''/'\''/g' | strip_root_slash
        awk '{print $2}' | sed "s/'//g" | strip_root_slash
      }

      # Create a git-enabled folder ready to receive git activity, like `git push'
      ensure_bare_repo() {
        declare repo_path="$1"
        if [ ! -d "$repo_path" ]; then
          mkdir -p "$repo_path"
          cd "$repo_path"
          git init --bare > /dev/null
          cd - > /dev/null
        fi
      }

      # Create a Git pre-receive hook in a git repo that runs `gitreceive hook' when the repo receives a new git push
      ensure_prereceive_hook() {
        declare repo_path="$1" home_dir="$2" self="$3"
        local hook_path="$repo_path/hooks/pre-receive"
        cd "$home_dir"
        cat > "$hook_path" <<EOF
      #!/bin/bash
      cat | $self hook
      EOF
        chmod +x "$hook_path"
        cd - > /dev/null
      }

      # When a repo receives a push, its pre-receive hook is triggered. This in turn executes `gitreceive hook', which is a
      # wrapper around this function. The repo is updated and its working tree tarred so that it can be piped to
      # `$home_dir/receiver'. The receiver script is setup by `setup_receiver_script()'.
      trigger_receiver() {
        declare repo="$1" user="$2" fingerprint="$3" home_dir="$4"
        # oldrev, newrev, refname are a feature of the way in which Git executes the pre-receive hook.
        # See https://www.kernel.org/pub/software/scm/git/docs/githooks.html
        while read oldrev newrev refname; do
          # Only run this script for the master branch. You can remove this
          # if block if you wish to run it for others as well.
          [[ "$refname" == "refs/heads/master" ]] && \
            git archive "$newrev" | "$home_dir/receiver" "$repo" "$newrev" "$user" "$fingerprint"
        done
      }

      # Places cursor at start of line, so that subsequent text replaces existing text. For example;
      # "remote: Updated branch 'master' of 'repo'. Deploying to dev." becomes
      # "------> Updated branch 'master' of 'repo'. Deploying to dev."
      strip_remote_prefix() {
        sed -u "s/^/"$'\e[1G'"/"
      }

      main() {
        # Be unforgiving about errors
        set -euo pipefail

        readonly SELF="$(absolute_path $0)"

        case "$1" in
        # Public commands

          init) # gitreceive init
            setup_git_user "$GITHOME" "$GITUSER"
            setup_receiver_script "$GITHOME" "$GITUSER"
            echo "Created receiver script in $GITHOME for user '$GITUSER'."
            ;;

          upload-key) # sudo gitreceive upload-key <username>
            declare name="$2"
            local key="$(cat)"
            install_authorized_key "$key" "$name" "$GITHOME" "$GITUSER" "$SELF"
            echo "$key" | generate_fingerprint
            ;;

        # Internal commands

          # Called by the 'forced command' when the git user first authenticates against the server
          run)
            declare user="$2" fingerprint="$3"
            export RECEIVE_USER="$user"
            export RECEIVE_FINGERPRINT="$fingerprint"
            export RECEIVE_REPO="$(echo "$SSH_ORIGINAL_COMMAND" | parse_repo_from_ssh_command)"
            local repo_path="$GITHOME/$RECEIVE_REPO"
            ensure_bare_repo "$repo_path"
            ensure_prereceive_hook "$repo_path" "$GITHOME" "$SELF"
            cd "$GITHOME"
            # $SSH_ORIGINAL_COMMAND is set by `sshd'. It stores the originally intended command to be run by `git push'. In
            # our case it is overridden by the 'forced command', so we need to reinstate it now that the 'forced command' has
            # run.
            git-shell -c "$(echo "$SSH_ORIGINAL_COMMAND" | awk '{print $1}') '$RECEIVE_REPO'"
            ;;

          # Called by the pre-receive hook
          hook)
            trigger_receiver "$RECEIVE_REPO" "$RECEIVE_USER" "$RECEIVE_FINGERPRINT" "$GITHOME" | strip_remote_prefix
            ;;

          *)
            echo "Usage: gitreceive <command> [options]"
            ;;
        esac
      }

      [[ "$0" == "$BASH_SOURCE" ]] && main $@
  - path: /home/git/receiver
    permissions: 0755
    owner: git:git
    content: |
      #!/bin/bash

      REPO=$1
      APP=$(echo $REPO | sed -e "s/\.git//g")
      REVISION=$2
      USER=$3

      #
      # Create workspace
      #
      echo "----> Unpacking repo..."
      mkdir -p /tmp/build/$REPO && cat | tar -x -C /tmp/build/$REPO
      test $? -ne 0 ; exit $?

      #
      # Detect app/stack
      #
      cd /tmp/build/$REPO
      #echo "----> Stack detected ..."

      #
      # Pre build hook
      #

      #
      # Build docker image
      #
      echo "----> Building docker image ..."
      docker build -t $APP .
      test $? -ne 0 ; exit $?

      #
      # Post build hook
      #

      #
      # Cleanup
      #
      echo "----> Cleanup build directory ..."
      rm -rf /tmp/build/$REPO

      exit 0
  - path: /home/git/register-keys
    permissions: 0755
    owner: git:git
    content: |
      #!/bin/bash
      #
      # Usage: register-keys '<github-username1>,<github-username2>'
      # Description: Register public key to gitreceive
      #

      IFS=,

      for user in $1
      do
        cat /home/$user/.ssh/authorized_keys.d/github-$user | sudo gitreceive upload-key $user
        echo "Registered key for $user"
      done

      exit 0
